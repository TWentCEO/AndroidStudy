## Android OS

* Linux 기반의 운영체제
* 오픈소스 기반
* 스마트폰 OS의 약 70% 차지함
* 스마트폰 뿐만 아니라 웨어러블 디바이스, TV, 자동차 등 다양한 플랫폼에서 동작할 수 있는 OS

# 앱 기본 항목

**안드로이드 앱**은 'Kotlin', 'JAVA', 'C++' 언어를 사용하여 작성할 수 있다. 최근에는 Kotlin이 대부분이라는 점에서 Kotlin을 공부할 예정이다. 

안드로이드 SDK 도구는 모든 데이터 및 리소스 파일과 함께 코드를 컴파일하여 하나의 APK를 만든다.

**안드로이드 패키지**는 .apk인 아카이브 파일로 한 개의 APK파일에는 앱의 모든 콘텐츠가 들어 있다. - 즉 App인 것이다.

## 보안기능

안드로이드 앱은 자체적인 보안 샌드박스에 속하며, 다음과 같은 안드로이드 보안 기능으로 보호된다.
* 안드로이드 운영체제는 멀티유저 Linux 시스템으로, 여기서 각 앱은 각기 다른 사용자와 같다.
* 기본적으로 시스템이 **<span style = 'background-color: black'> 각 앱에 고유한 Linux ID를 할당한다.</span>** (이 ID는 시스템만 사용할 수 있으며 앱에서는 인식하지 못함). 시스템은 앱 안의 **<span style = 'background-color: black'> 모든 파일에 대해 권한을 설정하여 해당 앱에 할당된 사용자 ID만 이에 액세스할 수 있도록 합니다.</span>**
* 각 프로세스에는 자체적인 가상 머신(VM)이 있고, 그렇기 때문에 한 앱의 코드가 다른 앱과는 격리된 상태로 실행됩니다.
* 기본적으로 모든 앱이 앱 자체의 Linux 프로세스에서 실행됩니다. **<span style = 'background-color: black'> Android 시스템은 앱의 구성 요소 중 어느 하나라도 실행해야 하는 경우 프로세스를 시작</span>**하고, **<span style = 'background-color: black'> 더 이상 필요 없거나 시스템이 다른 앱을 위해 메모리를 복구해야 하는 경우 해당 프로세스를 종료</span>**합니다.

이러한 방식으로 최소 권한의 원리를 구현한다고 한다.

정리하자면 작업을 수행하기 위해 필요한 권한만 가지고 그 외의 권한은 허용되지 않는다고 한다. 그렇기 때문에 안전한 환경이 구성되어 권한을 부여받지 못한 부분에는 엑세스할 수 없게 된다.

다른 앱과 데이터를 공유하고 시스템 서비스에 액세스하는 방법은 여러 가지가 있다.
* 두 개의 앱이 같은 Linux 사용자 ID를 공유하도록 설정할 수도 있습니다. 이 경우 두 앱은 서로 파일에 액세스할 수 있게 됩니다. 시스템 리소스를 절약하기 위해 사용자 ID가 동일한 앱들이 같은 Linux 프로세스에서 실행되고 같은 VM을 공유하도록 설정할 수도 있습니다. 또한 이러한 앱은 같은 인증서로 서명해야 합니다.
* 앱은 사용자의 연락처, SMS 메시지, 마운트 가능한 저장소(SD 카드), 카메라, 블루투스를 비롯한 여러 가지 기기 데이터에 액세스할 권한을 요청할 수 있습니다. 사용자는 이러한 권한을 명시적으로 부여해야 합니다. 자세한 내용은 [시스템 권한 사용](https://developer.android.com/training/permissions?hl=ko)을 참조하세요

# 앱 구성 요소
![안드로이드 구성요소](https://images.velog.io/images/jojo_devstory/post/9138556b-4a4c-4c48-a6dc-c9abc34e9b46/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202020-03-06%20%EC%98%A4%EC%A0%84%2011.51.43.png)

출처 https://velog.io/@jojo_devstory/안드로이드-Android-4대-컴포넌트

* Activity
	- 사용자와 상호작용하기 위한 진입점.
 	- 사용자 인터페이스를 포함한 화면 하나를 나타냄.
* Service
	- 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점
 	- 백그라운드에서 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행함. 
	- 서비스는 UI를 제공하지 않음.
	- 포그라운드 서비스 : 사용자에게 잘 보이는 작업. 포그라운드 서비스의 경우, 반드시 알림을 표시해야 하며, 사용자가 앱과 상호작용하지 않을 때도 계속 실행됨
    	- ex) 음악 재생
  	- 백그라운드 서비스 : 사용자에게 직접 보이지 않는 작업
    	- ex) 사용자에게 보이지 않는 작업 (저장소 압축, 게임 업데이트, 파일 압축 등)
    	- 앱이 API 레벨 26 이상을 대상으로 할 경우
        	- 즉시 실행해야 하는 작업 : Work Manager
        	- 지연 작업 : Alarm Manager
    - 바인드 서비스 : 앱 컴포넌트가 bindService를 호출해 서비스를 호출하면 서비스가 바인딩 됨. 바인딩 된 서비스는 클라이언트 - 서버 인터페이스를 제공해 서비스와 상호 작용 함. 여러개가 한꺼번에 바인딩 될 수 있고, 바인딩 된 컴포넌트가 모두 종료되면, 서비스도 종료됨
* Brodcast Receiver
	- 시스템이 정기적인 사용자가 플로우 밖에서 이벤트를 앱에 전달하도록 지원하는 구성요소
	- 앱으로 들어갈 수 있는 또 다른 명확한 진입점이기 때문에 현재 실행되지 않은 앱에서도 시스템이 브로드캐스트를 전달할 수 있음.
	- 예)
    	- 화면이 꺼졌거나
    	- 배터리가 부족하거나
    	- 사진을 캡처했거나
    	- 네트워크가 끊겼거나
* Contetnt Provider
	- 파일 시스템, SQLite 데이터베이스, 웹상이나 앱이 액세스할 수 있는 다른 모든 영구 저장 위치에 저장 가능한 앱 데이터의 공유형 집합을 관리.
	- 다른 앱은 콘텐츠 제공자를 통해 해당 데이터를 쿼리하거나, 콘텐츠 제공자가 허용할 경우에는 수정도 가능.
	- 데이터베이스에서 흔히 사용되는 CURD(Create, Read, Update, Delete)원칙을 준수
	- 예시
    	- 연락처 정보
    	- 갤러리 이미지 / 비디오

# 구성 요소 활성화
![인텐트](https://en.proft.me/media/android/android_intent_steps.png)

구성요소 4가지중 3가지(Acrivity, Services, Broadcast Reciver)는 **인텐트**라는 비동기식 메시지로 활성화된다.

**인텐트**는 런타임에서 각 구성 요소를 서로 Binding한다. 이것은 일종의 메신저라고 생각하면 된다. 

* 앱에 포함된 구성요소 이외에, 다른 앱의 구성요소와도 통신할 수 있음
  * 명시적 인텐트 : 특정 컴포넌트, 액티비티를 명확히 특정해 실행할 경우
    * 예시) A-Activity에서, B-Activity 실행을 호출할 경우
  * 암시적 인텐트 : 동작을 특정하긴 했지만, 실행될 대상이 달라질 수 있는 경우
    * 예시) 특정 URL을 실행 이라는 액션을 요청 경우, 웹 브라우저 기능을 가진 다수의 앱이 호출 될 수 있는 경우 
  

# Activity Lifecycle

* 앱의 **완성도**와 **안정성**을 높이기 위해 반드시 알아야 함
  * 다른 앱으로 전환 시, 비정상 종료 되는 문제
  * 사용자가 앱을 사용하지 않는데, 시스템 리소스가 소비되는 문제
  * 사용자가 앱을 나갔다가 돌아왔을 때, 진행상태가 저장되지 않는 문제
  * 화면이 가로 세로 전환 될 때, 비정상 종료되거나, 진행상태가 저장되지 않는 문제

![](https://developer.android.com/guide/components/images/activity_lifecycle.png)
​
## onCreate()
​
onCreate() 콜백 함수는 액티비티가 '생성된 상태'에서 실행이 된다. 
* 필수적으로 구성이 되어야하며 레이아웃 지정과 같이 한 번만 발생해야하는 로직을 실행
  * 클래스 범위 변수를 초기화
  * UI 구성(setContentView, xml 레이아웃 파일 정의)
* 기본적인 앱 시작 로직이 여기서 구현되어야 한다.
* saveInstance 매개 변수 수신 -> Activity 이전 저장 상태가 포함된 Bundle 객체
​
## onStart()
​
onStart() 콜백함수는 액티비티가 시작된 상태에 들어가기 직전에 실행이 된다. UI 관련 로직을 초기화하는 작업은 여기서 구현이 된다.
​
* 앱은 Activity를 포그라운드로 보내 상호작용할 수 있도록 준비

## onResume()
​
액티비티가 재개된 상태로 들어가기 직전에 실행된다. 전반적인 기능에 대한 코드는 여기서 주로 사용된다. 그 이유는 액티비티가 onPause()상태에서 다시 돌아올때 다시 구동되어야 하기 때문이다.
​
## onPause()
​
액티비티를 떠나게 되는 경우 처음 실행되는 콜백 함수로, 비활성화 시켜주는 로직이 작성된다. 주의할 점은 onPause()의 지속시간이다. 
* 시간이 짧음
* DB 처리, 네트워크 호출 등 중요하고 오래걸리는 작업은 수행해서는 안됨.
* 활동이 포그라운드에 있지 않지만, 잠시 후 다시 시작할 작업을 일시 중지 하거나 조정
* ex) 반투명 Activity가 띄워져 포커스는 없지만 화면에 보이는 상태
* 이 상태를 통해서, 실행중이지 않을 때 필요하지 않은 리소스를 해지할 수 있음
​
## onStop()
​
* Activity가 사용자에게 더 이상 표시 되지 않는 상태
* 위에서 언급한 DB처리, 네트워크 호출 등 부하가 큰 작업은 여기서 실행이 된다. 
* Activity가 중단되면, Android OS에서 리소스 관리를 위해, 해당 Activity가 포함된 프로세스를 소멸시킬 수 있음
​
## onDestory()
​
* 호출되는 케이스
  * finish 호출 되어 Activity가 종료될 때
  * configurationChange (ex 기기 회전, 멀티 윈도우)로 인해, 시스템이 Activity를 일시적으로 소멸 시킬 때
  * 액티비티가 완전히 소멸되기 직전에 호출되는 함수.


# View

* UI를 그리는 기본 구성요소
* CustomView를 만들기 위함

![Untitled](https://user-images.githubusercontent.com/24618293/204136897-70a64a1d-54e5-4fd1-bef5-251492733a80.png)

- 전위순회 방식을 쓰기 때문에, 부모 부터 자식 뷰 순서로 그려지게 됨

## measure
    - 뷰의 크기를 계산
    - 모든 뷰는 각각 자신의 width, height 를 계산
    - measure 과정에서, 부모 - 자식 뷰간의 크기 정보 전달을 위해 2가지 클래스 사용
        - ViewGroup.LayoutParams : 자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청 할 때 사용, (how big)
            - DP, PX.. : 자식뷰가 원하는 사이즈
            - MATCH_PARENT : 부모 뷰 사이즈와 똑같이 자식뷰 사이즈 지정
            - WRAP_CONTENT : 부모 뷰 안에서, content 를 표현할 수 있는 fit 한 사이즈 지정
        - ViewGroup.MeasureSpecs : 부모 뷰가 자식 뷰에게 요구사항을 전달할 때 사용
            - UNSPECIFIED : 부모 뷰는 자식 뷰가 원하는 사이즈로 결정
            - EXACTLY : 부모 뷰가 자식 뷰의 사이즈를 정확히 지정할 때
            - AT_MOST : 부모 뷰가 자식 뷰의 최대 사이즈를 지정할 때
## layout
    - 뷰의 크기와 위치를 할당
    - 부모기준의 상대적 위치 (left, top, right, bottom) 을 계산
## draw
    - 뷰를 그리는 단계
        - Canvas : 뷰의 모양을 그리는 객체
        - Paint : 뷰의 색상을 칠하는 객체
    - measure, layout 에서 측정한 크기와, 계산한 위치에 뷰를 그림
    - 이 콜백은 언제든 다시 호출 될 수 있음
        - scroll 이나 swipe 를 하게 되면 뷰는 onDraw 다시 호출
        - 객체 할당과 같이 리소스가 많이 소모되는 로직은 추가하지 말 것

## ViewUpdate : 런타임에 뷰를 다시 그리게 하는 함수
    - invalidate : view 에 변화가 생겨서 다시 그려야 할 때
        - color 변화 등
    - requestLayout : view 를 처음부터 그려야 할 때